"""
Initial plan:
    - start island id at 1, count at 0
    - go through positions. each time an island is added with no neighbors, 
      fill its cell with island id and bump count.
    - if an island is added and it has a neighbor, count each neighbor cell with different IDs. Overwrite them
      with new island's ID (bfs/dfs), and reduce island count for number of islands joined 
    - return island count at end
Flaws:
    - Doing bfs/dfs overwrites can have pathological edge case devolving to O((n x m)^2) - imagine a case where 
      positions contains every cell in the grid, in incrementing order ([0,0], [0,1], [0,2], ...)

Better approach:
    - Initialize UF that uses Union by rank, also island id and count
    - For each position, fill with id:
        - If filled in with no neighbors, add 1 to count and increment id 
        - If neighbors, union them. Only decrement count if filled cell has 2 or more neighbors, since we're joining them
            - will need to check roots of all neighbors (edge case: c shaped island with new cell making it into a ring)
    - should be O(n x m) for space, not sure on time; we could need to do union/find for each cell as described above. 
-----
Whenever we add, do a cardinal check:
if all are 0, we have 1 more island. 
If we find 1-4 on the cardinal:
- 1 adjacent just means we have the same number of islands
- 2 adjacent means we join 2 existing islands, so we have 1 less 
- 3 means we join 3 existing, so we have 2 less 
- 4 means we join 4, so we have 3 less. 
"""
from typing import List

def get_neighbors(grid, y, x, deltas, only_filled=True):
    neighbors = []
    for dy, dx in deltas:
        ny, nx = y + dy, x + dx
        if 0 <= ny < len(grid) and 0 <= nx < len(grid[0]):
          if not only_filled or grid[ny][nx] == 1:
            neighbors.append(grid[ny][nx])
    return neighbors

def get_cardinal_neighbors(grid, y, x, only_filled=True):
  deltas = [(0, 1), (0, -1), (1, 0), (-1, 0)]
  return get_neighbors(grid, y, x, deltas, only_filled)

def get_diagonal_neighbors(grid, y, x, only_filled=True):
  # If only_filled=False, returns in order: UL, UR, DR, DL
  deltas = [(-1, -1), (-1, 1), (1, 1), (1, -1)]
  return get_neighbors(grid, y, x, deltas, only_filled)

def get_joining_diagonals(grid, y, x):
  
  diagonals = get_diagonal_neighbors(grid, y, x, only_filled=False)



def get_islands_delta(grid, y, x):
    # When all 4 neighbors are disjoint,
    # we do the following:
    disjoint_deltas = {
        0: 1, # No neighbors: 1 new island
        1: 0, # 1 neighbor: gets extended
        2: -1, # 2 neighbors, lose 1 island
        3: -2, # 3 neighbors, lose 2
        4: -3  # 4 neighbors, lose 3
    }
    neighbors = get_cardinal_neighbors(grid, y, x)
    initial_delta = disjoint_deltas[len(neighbors)]
    # If any of the neighbors are already part of the same island,
    # we aren't rejoining them. 
    return initial_delta - get_joining_diagonals


class Solution:
    def numIslands2(self, m: int, n: int, positions: List[List[int]], expected) -> List[int]:
        grid = [[0] * n for _ in range(m)]
        islands = 0
        island_counts = []
        i = 0 
        for y, x in positions:
            was = grid[y][x]
            if grid[y][x] == 0:
                d_islands = get_islands_delta(grid, y, x)
                islands = max(1, islands + d_islands) if d_islands < 0 else islands + d_islands
            island_counts.append(islands)
            grid[y][x] = 1

            if island_counts[-1] != expected[i]:
              grid[y][x] = '*'
              for row in grid:
                print(' '.join([str(item) for item in row]))
              print(f"was: {was}, then set to 1")
              raise RuntimeError

            i += 1
        return island_counts

m = 21
n = 71 
positions = [[19,28],[14,38],[15,44],[17,12],[6,19],[11,69],[2,30],[7,43],[19,6],[7,29],[10,21],[17,55],[20,66],[12,28],[11,64],[12,52],[18,15],[2,52],[10,20],[0,50],[16,5],[17,25],[12,67],[6,45],[13,17],[5,55],[10,42],[20,17],[3,26],[20,61],[14,10],[9,1],[9,69],[6,29],[11,53],[3,66],[4,45],[12,65],[11,35],[5,67],[18,35],[2,57],[12,12],[13,53],[9,65],[13,0],[3,18],[13,39],[5,54],[20,43],[19,29],[17,37],[17,45],[3,38],[2,61],[2,65],[3,21],[5,40],[10,4],[12,36],[2,8],[3,33],[15,4],[13,35],[0,45],[20,29],[10,66],[19,7],[0,46],[19,11],[10,22],[19,0],[0,9],[2,20],[16,64],[10,37],[16,49],[4,20],[20,68],[10,38],[17,59],[15,54],[17,60],[19,18],[0,60],[9,62],[3,69],[10,44],[15,2],[14,44],[17,0],[18,42],[17,28],[11,10],[11,42],[11,67],[0,32],[8,0],[17,6],[7,26],[17,65],[17,66],[7,38],[8,17],[7,60],[0,16],[7,59],[18,8],[16,63],[7,0],[11,46],[0,7],[6,4],[2,63],[8,56],[18,18],[12,70],[2,15],[14,65],[13,52],[11,0],[10,48],[7,8],[11,44],[0,35],[4,64],[6,36],[16,17],[7,34],[1,33],[11,60],[17,11],[4,58],[4,9],[18,7],[15,40],[11,24],[17,3],[7,9],[1,38],[1,14],[15,21],[14,68],[14,69],[16,40],[5,60],[18,46],[15,51],[7,65],[1,34],[15,55],[19,63],[5,35],[20,9],[13,1],[20,69],[19,67],[17,44],[12,44],[10,49],[12,43],[14,21],[18,11],[11,9],[4,56],[6,70],[8,54],[1,55],[17,47],[18,38],[3,31],[16,37],[13,7],[15,6],[18,33],[4,60],[17,40],[7,3],[3,32],[13,41],[5,62],[17,4],[20,5],[15,32],[19,31],[8,69],[19,58],[3,35],[6,64],[0,37],[15,56],[6,46],[4,42],[4,51],[2,7],[7,13],[20,47],[10,29],[12,18],[20,52],[5,5],[12,34],[1,57],[7,32],[3,58],[14,29],[2,32],[2,46],[14,5],[3,9],[19,68],[18,16],[19,2],[6,23],[20,3],[10,69],[9,0],[0,13],[20,38],[6,14],[0,21],[6,50],[2,5],[1,20],[5,20],[1,5],[10,0],[7,6],[15,13],[8,21],[7,14],[9,9],[19,8],[13,25],[5,30],[1,16],[18,19],[16,44],[4,5],[15,37],[20,14],[20,8],[5,23],[13,44],[17,56],[13,62],[2,18],[1,58],[17,2],[20,40],[8,9],[8,52],[6,24],[19,65],[7,48],[20,51],[2,21],[7,39],[11,27],[7,22],[12,6],[19,12],[12,66],[0,55],[20,62],[11,20],[2,35],[2,0],[6,7],[5,41],[9,37],[8,44],[16,15],[9,48],[18,54],[19,52],[19,24],[19,46],[5,0],[19,50],[2,37],[18,31],[6,20],[4,59],[5,39],[9,38],[19,51],[3,67],[11,33],[7,57],[13,47],[20,64],[8,24],[13,69],[4,11],[4,46],[13,32],[18,3],[20,54],[18,17],[7,5],[15,12],[12,7],[6,11],[5,4],[17,26],[7,12],[12,68],[8,45],[8,2],[15,34],[12,20],[1,26],[6,54],[19,16],[0,17],[9,13],[4,65],[12,58],[11,52],[8,32],[18,32],[11,50],[9,50],[17,13],[11,17],[16,53],[18,26],[2,42],[14,58],[0,23],[19,44],[9,39],[15,47],[11,70],[10,35],[8,41],[15,39],[20,50],[2,50],[17,39],[1,28],[7,63],[16,61],[15,58],[19,17],[11,40],[20,46],[12,41],[6,32],[2,67],[4,52],[14,24],[0,43],[17,34],[6,56],[2,53],[1,69],[0,11],[16,48],[1,47],[14,12],[7,23],[8,37],[17,18],[7,27],[7,2],[10,63],[13,6],[3,23],[12,8],[1,52],[11,30],[9,57],[16,57],[9,58],[4,38],[18,36],[10,17],[20,24],[13,64],[18,37],[4,21],[17,33],[2,33],[15,10],[8,40],[14,52],[19,1],[2,45],[11,55],[3,40],[8,31],[20,57],[6,33],[6,22],[6,28],[2,11],[4,15],[4,31],[16,26],[9,27],[10,61],[5,52],[3,68],[0,19],[13,40],[0,52],[18,22],[1,24],[13,29],[12,33],[16,58],[19,66],[6,62],[18,40],[17,58],[2,34],[15,63],[8,23],[14,50],[20,16],[6,9],[8,1],[3,0],[20,10],[15,23],[1,0],[13,4],[8,25],[10,13],[12,9],[18,39],[3,24],[20,63],[16,39],[7,36],[15,65],[13,10],[19,20],[3,54],[12,35],[17,49],[17,31],[14,48],[18,65],[2,44],[9,51],[17,64],[16,36],[7,10],[5,9],[12,13],[6,59],[13,21],[8,14],[10,67],[20,56],[6,53],[18,25],[14,39],[8,70],[10,27],[0,48],[0,36],[12,56],[3,28],[15,14]]
expected = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,46,47,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,61,62,62,62,63,63,64,65,66,67,68,69,70,71,71,72,73,73,74,75,76,77,78,79,79,80,81,82,83,83,83,84,85,86,87,88,88,89,90,91,92,92,93,93,93,94,95,96,97,98,98,99,100,101,100,101,102,103,103,104,105,106,107,108,109,110,110,111,112,111,112,113,114,114,115,116,117,118,118,118,119,120,121,122,122,122,123,124,125,125,125,126,126,126,126,126,126,125,125,126,127,128,129,130,131,132,132,133,134,135,135,135,136,135,136,137,137,138,139,140,140,141,142,143,144,144,144,145,146,146,147,148,149,150,151,152,153,153,154,154,155,155,156,157,157,156,156,157,158,159,158,157,158,159,160,161,162,163,163,163,163,162,163,164,165,164,165,165,166,167,167,167,166,166,166,167,166,166,165,165,166,166,166,166,167,166,167,167,168,169,169,168,168,169,170,171,171,170,170,170,170,170,171,172,172,172,173,174,174,175,175,176,176,177,178,179,179,178,177,177,177,176,176,177,178,179,180,181,181,182,182,183,183,184,183,183,183,182,183,182,182,182,182,182,183,184,184,185,185,185,185,186,186,187,186,186,185,186,187,187,188,189,189,190,191,192,193,193,194,193,193,194,194,194,195,195,196,197,198,198,197,198,197,197,197,197,197,198,199,200,201,201,202,203,203,204,204,203,203,203,203,202,203,203,204,204,204,205,206,207,207,207,207,207,207,208,206,205,204,203,203,203,203,202,202,203,204,204,205,205,205,205,206,207,207,207,208,209,209,208,209,208,208,209,210,210,209,208,206,206,206,205,204,204,203,204,204,204,203,203,203,204,204,205,205,205,204,203,203,201,201,201,201,201,202,203,200,200,200,201,200,200,200,199,199,199,198,198,198,198,198,197,197,197,197,195,195,194,195,194,195,196,196]
s = Solution()
s.numIslands2(m, n, positions, expected)
